<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nugget: PSYQo concepts</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nugget
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">PSYQo concepts</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md37"></a> The library has only three mandatory classes, and everything else is optional. The library tries to heavily follow the "pay only what you use" pattern. As a result, aside from the <code>GPU</code> class, things like font drawing, cdrom access, or input processing have to be explicitly instantiated and initialized.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
The &lt;tt&gt;Application&lt;/tt&gt; class</h1>
<p>The PSYQo library wants to take control of the whole execution flow. In order to do so, it needs to first be provided with a derived instance of the <code>Application</code> class. The method to do so can simply done the following way:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyApplication : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/d00/classpsyqo_1_1Application.html">psyqo::Application</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../dc/d07/crc32_2main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    MyApplication app;</div>
<div class="line">    <span class="keywordflow">return</span> app.run();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspsyqo_1_1Application_html"><div class="ttname"><a href="../../d0/d00/classpsyqo_1_1Application.html">psyqo::Application</a></div><div class="ttdoc">The application class.</div><div class="ttdef"><b>Definition</b> application.hh:49</div></div>
<div class="ttc" id="acrc32_2main_8c_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="../../dc/d07/crc32_2main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> main.c:36</div></div>
</div><!-- fragment --><p> The <code>run</code> method will never return. Now, the problem with the above example is that it won't do anything. We need to add some additional code to the <code>Application</code> class.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyApplication : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/d00/classpsyqo_1_1Application.html">psyqo::Application</a> {</div>
<div class="line">    <span class="keywordtype">void</span> prepare()<span class="keyword"> override </span>{ <span class="comment">/* Initialize the GPU */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> createScene()<span class="keyword"> override </span>{ <span class="comment">/* Create the root scene */</span> }</div>
<div class="line">};</div>
</div><!-- fragment --><p>These two methods are called during the execution of the application. The first one is called before the application starts, when the hardware hasn't been initialized yet, and the second one is called every time the scene stack is empty.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
The &lt;tt&gt;Scene&lt;/tt&gt; class</h1>
<p>The PSYQo library uses the concept of a <code>Scene</code> to represent the current state of the application. A minimum of one scene is needed to get the application to function properly.</p>
<p>The idea behind the scenes system is that state transitions is usually the hardest part of applications. By using the <code>Scene</code> class, we can easily create a scene stack, which will allow us to easily switch between different states of the application. Now, this doesn't mean the scene stack is mandatory, but it is a good idea to use it. An application with only a single root scene is an acceptable outcome.</p>
<p>Both the <code>Scene</code> class and the <code>Application</code> class have the methods <code>pushScene</code> and <code>popScene</code> to push and pop scenes. The <code>pushScene</code> method will push its scene argument to the scene stack. The <code>popScene</code> method will remove the top scene from the stack, returning its pointer.</p>
<p>As a result, our minimum working application becomes the following:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyScene : <span class="keyword">public</span> <a class="code hl_class" href="../../d3/d3c/classpsyqo_1_1Scene.html">psyqo::Scene</a> { };</div>
<div class="line">MyScene rootScene;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyApplication : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/d00/classpsyqo_1_1Application.html">psyqo::Application</a> {</div>
<div class="line">    <span class="keywordtype">void</span> createScene()<span class="keyword"> override </span>{ pushScene(&amp;rootScene); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../dc/d07/crc32_2main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    MyApplication app;</div>
<div class="line">    <span class="keywordflow">return</span> app.run();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspsyqo_1_1Scene_html"><div class="ttname"><a href="../../d3/d3c/classpsyqo_1_1Scene.html">psyqo::Scene</a></div><div class="ttdoc">The Scene class.</div><div class="ttdef"><b>Definition</b> scene.hh:43</div></div>
</div><!-- fragment --><p>Now, this still won't do much, but we're making progress. The next step is to add some code to the <code>Scene</code> class, which will have to interact with the <code>GPU</code> class.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
The &lt;tt&gt;GPU&lt;/tt&gt; class</h1>
<p>Our third and last unavoidable class is the <code>GPU</code> class. The <code>GPU</code> class is basically the heartbeat of the application. There is no need to instantiate it as the <code>Application</code> class will do it for us. This means it's possible to retrieve the <code>GPU</code> instance from the <code>Application</code> class using the method <code>gpu()</code>.</p>
<p>The class is responsible for drawing primitives on screen, and keeping the pace of the application. This means it also holds the timers for the application. It needs to be initialized from the <code>prepare</code> method of the <code>Application</code> class. This is done using a simple configuration system to create the rendering context.</p>
<p>When the application is running, the top scene on the stack will have its <code>frame</code> method called to draw the scene. This is the last piece of our puzzle in order to create a minimal working application. We can even easily create a simple animation using only what we have learned so far.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MyApplication : <span class="keyword">public</span> <a class="code hl_class" href="../../d0/d00/classpsyqo_1_1Application.html">psyqo::Application</a> {</div>
<div class="line">    <span class="keywordtype">void</span> prepare() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> createScene() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyScene : <span class="keyword">public</span> <a class="code hl_class" href="../../d3/d3c/classpsyqo_1_1Scene.html">psyqo::Scene</a> {</div>
<div class="line">    <span class="keywordtype">void</span> frame() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyApplication app;</div>
<div class="line">MyScene rootScene;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApplication::prepare() {</div>
<div class="line">    <a class="code hl_struct" href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html">psyqo::GPU::Configuration</a> config;</div>
<div class="line">    config.<a class="code hl_function" href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html#a289d2de35de4ecfb50b3c9e1ff50ac97">set</a>(<a class="code hl_enumvalue" href="../../db/dcc/classpsyqo_1_1GPU.html#ad9467abab41694f0596bbacf7a238b02ad2799ae4d9532e75c7b76f8fe7c80560">psyqo::GPU::Resolution::W320</a>)</div>
<div class="line">        .<a class="code hl_function" href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html#a289d2de35de4ecfb50b3c9e1ff50ac97">set</a>(<a class="code hl_enumvalue" href="../../db/dcc/classpsyqo_1_1GPU.html#ae208ebd940147f5f5a9a9b50b1be6696ae1f2d5134ed2543d38a0de9751cf75d9">psyqo::GPU::VideoMode::AUTO</a>)</div>
<div class="line">        .<a class="code hl_function" href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html#a289d2de35de4ecfb50b3c9e1ff50ac97">set</a>(<a class="code hl_enumvalue" href="../../db/dcc/classpsyqo_1_1GPU.html#ac42f63ffdde29ec0ceb3e6e24e559c3eafd93ed15ae10316f799cee8d5e6e24c0">psyqo::GPU::ColorMode::C15BITS</a>)</div>
<div class="line">        .<a class="code hl_function" href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html#a289d2de35de4ecfb50b3c9e1ff50ac97">set</a>(<a class="code hl_enumvalue" href="../../db/dcc/classpsyqo_1_1GPU.html#a48806496d1618b7e7abd57e57829306aa9bc5e7fe934fe08249e3aa2e0d3678ed">psyqo::GPU::Interlace::PROGRESSIVE</a>);</div>
<div class="line">    gpu().initialize(config);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApplication::createScene() {</div>
<div class="line">    pushScene(&amp;rootScene);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::frame() {</div>
<div class="line">    <a class="code hl_union" href="../../dd/d74/unionpsyqo_1_1Color.html">psyqo::Color</a> <a class="code hl_variable" href="../../d2/d6e/syscalls_8h.html#a6fa33b6bca5496c4844a4467ea3457da">c</a> = {{.<a class="code hl_variable" href="../../dd/d74/unionpsyqo_1_1Color.html#ae58f14f954f3cdbcc490e7b7343ddcee">r</a> = 0, .g = 0, .b = uint8_t(gpu().getFrameCount() % 255)}};</div>
<div class="line">    gpu().clear(<a class="code hl_variable" href="../../d2/d6e/syscalls_8h.html#a6fa33b6bca5496c4844a4467ea3457da">c</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../dc/d07/crc32_2main_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordflow">return</span> app.run();</div>
<div class="line">}</div>
<div class="ttc" id="aclasspsyqo_1_1GPU_html_a48806496d1618b7e7abd57e57829306aa9bc5e7fe934fe08249e3aa2e0d3678ed"><div class="ttname"><a href="../../db/dcc/classpsyqo_1_1GPU.html#a48806496d1618b7e7abd57e57829306aa9bc5e7fe934fe08249e3aa2e0d3678ed">psyqo::GPU::Interlace::PROGRESSIVE</a></div><div class="ttdeci">@ PROGRESSIVE</div></div>
<div class="ttc" id="aclasspsyqo_1_1GPU_html_ac42f63ffdde29ec0ceb3e6e24e559c3eafd93ed15ae10316f799cee8d5e6e24c0"><div class="ttname"><a href="../../db/dcc/classpsyqo_1_1GPU.html#ac42f63ffdde29ec0ceb3e6e24e559c3eafd93ed15ae10316f799cee8d5e6e24c0">psyqo::GPU::ColorMode::C15BITS</a></div><div class="ttdeci">@ C15BITS</div></div>
<div class="ttc" id="aclasspsyqo_1_1GPU_html_ad9467abab41694f0596bbacf7a238b02ad2799ae4d9532e75c7b76f8fe7c80560"><div class="ttname"><a href="../../db/dcc/classpsyqo_1_1GPU.html#ad9467abab41694f0596bbacf7a238b02ad2799ae4d9532e75c7b76f8fe7c80560">psyqo::GPU::Resolution::W320</a></div><div class="ttdeci">@ W320</div></div>
<div class="ttc" id="aclasspsyqo_1_1GPU_html_ae208ebd940147f5f5a9a9b50b1be6696ae1f2d5134ed2543d38a0de9751cf75d9"><div class="ttname"><a href="../../db/dcc/classpsyqo_1_1GPU.html#ae208ebd940147f5f5a9a9b50b1be6696ae1f2d5134ed2543d38a0de9751cf75d9">psyqo::GPU::VideoMode::AUTO</a></div><div class="ttdeci">@ AUTO</div></div>
<div class="ttc" id="astructpsyqo_1_1GPU_1_1Configuration_html"><div class="ttname"><a href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html">psyqo::GPU::Configuration</a></div><div class="ttdef"><b>Definition</b> configuration.hh:29</div></div>
<div class="ttc" id="astructpsyqo_1_1GPU_1_1Configuration_html_a289d2de35de4ecfb50b3c9e1ff50ac97"><div class="ttname"><a href="../../d1/d8f/structpsyqo_1_1GPU_1_1Configuration.html#a289d2de35de4ecfb50b3c9e1ff50ac97">psyqo::GPU::Configuration::set</a></div><div class="ttdeci">Configuration &amp; set(Resolution resolution)</div><div class="ttdef"><b>Definition</b> configuration.hh:30</div></div>
<div class="ttc" id="asyscalls_8h_html_a6fa33b6bca5496c4844a4467ea3457da"><div class="ttname"><a href="../../d2/d6e/syscalls_8h.html#a6fa33b6bca5496c4844a4467ea3457da">c</a></div><div class="ttdeci">static int c</div><div class="ttdef"><b>Definition</b> syscalls.h:121</div></div>
<div class="ttc" id="aunionpsyqo_1_1Color_html"><div class="ttname"><a href="../../dd/d74/unionpsyqo_1_1Color.html">psyqo::Color</a></div><div class="ttdoc">The Color struct.</div><div class="ttdef"><b>Definition</b> common.hh:91</div></div>
<div class="ttc" id="aunionpsyqo_1_1Color_html_ae58f14f954f3cdbcc490e7b7343ddcee"><div class="ttname"><a href="../../dd/d74/unionpsyqo_1_1Color.html#ae58f14f954f3cdbcc490e7b7343ddcee">psyqo::Color::r</a></div><div class="ttdeci">uint8_t r</div><div class="ttdef"><b>Definition</b> common.hh:93</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
The scene stack</h1>
<p>When creating an application with multiple scenes, only the top scene on the stack will be active and drawn. When pushing and popping scenes, they will get notified of the change. When a scene becomes active, its <code>start</code> method will be called. When a scene becomes inactive, its <code>teardown</code> method will be called. Both methods have a <code>reason</code> argument, which can be used to determine the reason for the change.</p>
<p>When a scene is started, it can be because it just got pushed to the stack (which is the <code>Create</code> reason), or because it became the top scene on the stack due to a call to <code>popScene</code> (which is the <code>Resume</code> reason).</p>
<p>When a scene is teardown, it can be because it just got popped from the stack (which is the <code>Destroy</code> reason), or because a new scene arrived on top of the stack due to a call to <code>pushScene</code> (which is the <code>Pause</code> reason).</p>
<p>By encapsulating scene states that way, we can simplify the general approach of state transitions within the whole application.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Primitives</h1>
<p>The PSYQo library provides a number of primitives to draw on screen. There are multiple ways to draw a primitive through the <code>GPU</code> class. First, we can just use the <code>sendPrimitive</code> method of the <code>GPU</code> class:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> MyScene::frame() {</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html">psyqo::Prim::Rectangle</a> rect;</div>
<div class="line">    rect.<a class="code hl_variable" href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html#aa347d6e89e378752d06ec2b19bb6b462">position</a> = {{.<a class="code hl_variable" href="../../d5/d3c/unionpsyqo_1_1Vertex.html#ac9faa6d7d097eebb21b32c866e17e0e2">x</a> = 24, .y = 24}};</div>
<div class="line">    rect.<a class="code hl_variable" href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html#a394b426f0370860375d0cf062b88fe0b">size</a> = {{.<a class="code hl_variable" href="../../d5/d3c/unionpsyqo_1_1Vertex.html#aec80aad106f8e9cbafa2d34245349b39">w</a> = 48, .h = 48}};</div>
<div class="line">    rect.<a class="code hl_function" href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html#a0675acc2334bd5ee9e6b7cee6df9366c">setColor</a>({{.r = 255, .g = 0, .b = 0}});</div>
<div class="line"> </div>
<div class="line">    gpu().sendPrimitive(rect);</div>
<div class="line">}</div>
<div class="ttc" id="astructpsyqo_1_1Prim_1_1Rectangle_html"><div class="ttname"><a href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html">psyqo::Prim::Rectangle</a></div><div class="ttdoc">The Rectangle primitive.</div><div class="ttdef"><b>Definition</b> rectangles.hh:46</div></div>
<div class="ttc" id="astructpsyqo_1_1Prim_1_1Rectangle_html_a0675acc2334bd5ee9e6b7cee6df9366c"><div class="ttname"><a href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html#a0675acc2334bd5ee9e6b7cee6df9366c">psyqo::Prim::Rectangle::setColor</a></div><div class="ttdeci">Rectangle &amp; setColor(Color c)</div><div class="ttdef"><b>Definition</b> rectangles.hh:50</div></div>
<div class="ttc" id="astructpsyqo_1_1Prim_1_1Rectangle_html_a394b426f0370860375d0cf062b88fe0b"><div class="ttname"><a href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html#a394b426f0370860375d0cf062b88fe0b">psyqo::Prim::Rectangle::size</a></div><div class="ttdeci">Vertex size</div><div class="ttdef"><b>Definition</b> rectangles.hh:69</div></div>
<div class="ttc" id="astructpsyqo_1_1Prim_1_1Rectangle_html_aa347d6e89e378752d06ec2b19bb6b462"><div class="ttname"><a href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html#aa347d6e89e378752d06ec2b19bb6b462">psyqo::Prim::Rectangle::position</a></div><div class="ttdeci">Vertex position</div><div class="ttdef"><b>Definition</b> rectangles.hh:68</div></div>
<div class="ttc" id="aunionpsyqo_1_1Vertex_html_ac9faa6d7d097eebb21b32c866e17e0e2"><div class="ttname"><a href="../../d5/d3c/unionpsyqo_1_1Vertex.html#ac9faa6d7d097eebb21b32c866e17e0e2">psyqo::Vertex::x</a></div><div class="ttdeci">int16_t x</div><div class="ttdef"><b>Definition</b> common.hh:50</div></div>
<div class="ttc" id="aunionpsyqo_1_1Vertex_html_aec80aad106f8e9cbafa2d34245349b39"><div class="ttname"><a href="../../d5/d3c/unionpsyqo_1_1Vertex.html#aec80aad106f8e9cbafa2d34245349b39">psyqo::Vertex::w</a></div><div class="ttdeci">int16_t w</div><div class="ttdef"><b>Definition</b> common.hh:50</div></div>
</div><!-- fragment --><p>This isn't very efficient, but it is easy to use. This is a blocking function, and nothing can happen while the primitive is being sent.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Fragments</h1>
<p>The best method to send primitives however is to try and collect them into a batch, called <code>Fragment</code> within PSYQo. This is a collection of primitives that can be sent to the GPU in a single call. A fragment needs to have a <code>uint32_t head</code> member, reserved for the usage of the GPU, followed immediately by the primitives to send, and a <code>size_t getActualFragmentSize()</code> method that returns the size of the primitives to send in words.</p>
<p>We can then send the fragment to the GPU using the <code>sendFragment</code> method of the <code>GPU</code> class.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>MyFragment {</div>
<div class="line">    <a class="code hl_function" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a> head;</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d64/structpsyqo_1_1Prim_1_1Rectangle.html">psyqo::Prim::Rectangle</a> rects[3];</div>
<div class="line">    <span class="keywordtype">size_t</span> getActualFragmentSize()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(rects) /  <span class="keyword">sizeof</span>(<a class="code hl_function" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::frame() {</div>
<div class="line">    MyFragment fragment;</div>
<div class="line">    fragment.rects[0].position = {{.x = 24, .y = 24}};</div>
<div class="line">    fragment.rects[0].size = {{.w = 48, .h = 48}};</div>
<div class="line">    fragment.rects[0].setColor({{.r = gpu().getFrameCount() % 255, .g = 0, .b = 0}});</div>
<div class="line">    fragment.rects[1].position = {{.x = 72, .y = 72}};</div>
<div class="line">    fragment.rects[1].size = {{.w = 96, .h = 96}};</div>
<div class="line">    fragment.rects[1].setColor({{.r = 0, .g = gpu().getFrameCount() % 255, .b = 0}});</div>
<div class="line">    fragment.rects[2].position = {{.x = 144, .y = 144}};</div>
<div class="line">    fragment.rects[2].size = {{.w = 192, .h = 192}};</div>
<div class="line">    fragment.rects[2].setColor({{.r = 0, .g = 0, .b = gpu().getFrameCount() % 255}});</div>
<div class="line">    gpu().sendFragment(fragment);</div>
<div class="line">}</div>
<div class="ttc" id="asyscalls_8h_html_afc8cf906e2f0373da36f37c55ce569a1"><div class="ttname"><a href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a></div><div class="ttdeci">void uint32_t(classId, spec)</div></div>
</div><!-- fragment --><p>Using <code>sendFragment</code> will be more efficient than using <code>sendPrimitive</code> for each primitive. It is a blocking call, however background processing is not halted, and events can be fired while sending fragments.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Fragment caching</h1>
<p>Now, the whole idea behind fragments is that it's possible to cache them in memory, only changing the relevant portion of the primitives. This is useful for example when drawing a HUD, or a menu, that solely changes over time. The above example would be inefficient, as it would need to re-create the entire fragment every frame. It can be rewritten the following way:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">MyFragment fragment;</div>
<div class="line"> </div>
<div class="line">MyScene::MyScene() {</div>
<div class="line">    fragment.rects[0].position = {{.x = 24, .y = 24}};</div>
<div class="line">    fragment.rects[0].size = {{.w = 48, .h = 48}};</div>
<div class="line">    fragment.rects[1].position = {{.x = 72, .y = 72}};</div>
<div class="line">    fragment.rects[1].size = {{.w = 96, .h = 96}};</div>
<div class="line">    fragment.rects[2].position = {{.x = 144, .y = 144}};</div>
<div class="line">    fragment.rects[2].size = {{.w = 192, .h = 192}};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::frame() {</div>
<div class="line">    fragment.rects[0].setColor({{.r = gpu().getFrameCount() % 255, .g = 0, .b = 0}});</div>
<div class="line">    fragment.rects[1].setColor({{.r = 0, .g = gpu().getFrameCount() % 255, .b = 0}});</div>
<div class="line">    fragment.rects[2].setColor({{.r = 0, .g = 0, .b = gpu().getFrameCount() % 255}});</div>
<div class="line">    gpu().sendFragment(fragment);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This way, the fragment will be initialized and filled with the primitives only once, and then reused for every frame, with only the necessary changes being applied.</p>
<p>Note that the fragment is not copied when it is sent to the GPU, so it is not safe to mutate the fragment within event callbacks, as they can be dispatched during <code>sendFragment</code>. This could potentially create visual glitches as the fragment could be modified while it's being sent to the GPU.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Fragment chaining</h1>
<p>Fragments can be chained together to create a sequence of primitives to draw. The advantage here is that the code no longer has to wait on <code>sendFragment</code> to finish, before moving on to the next phase of computation. Instead, the chained fragments will be sent in the background to the GPU in the order they were chained, and the code can continue executing. The actual sending of the fragments will start when the <code>frame</code> method returns, and the GPU is ready to accept new fragments. The chain will continue to be sent out to the GPU when the next call to <code>frame</code> is made, so double buffering of the fragments becomes necessary. In order to help with this, the <code>GPU</code> class has a <code>getParity</code> method, which will return the current parity of the GPU, which can be used to determine which buffer to write to.</p>
<p>An important limitation of the chaining mechanism is that the maximum size of a fragment is 255 words. This is a limitation of the PS1 hardware, and not of the PSYQo library. The library will assert if the fragment size exceeds this limit when being chained. Note that it is still possible to send larger fragments using <code>sendFragment</code>, but care must be taken to do so only when the previous chain has been fully sent. This also means that once the user decides to use chaining, they must use it for all fragments, and not mix and match with <code>sendFragment</code>. This means using a different general paradigm for the drawing code.</p>
<p>Other than the size limitation, one simply need to call the <code>chain</code> method of the <code>GPU</code> class, and pass the fragment to chain.</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Ordering Tables</h1>
<p>When doing 3D rendering, since the PS1 GPU doesn't have a Z-buffer, the order in which primitives are drawn is important. The PSYQo library provides a way to sort primitives based on their Z position, using the <code>OrderingTable</code> class. The class is a template taking a number of "buckets" as a parameter. When inserting a primitive into the ordering table, one needs to provide a z value, which represents the depth of the primitive. This z value will be used to select which bucket the primitive will be inserted into. No ordering is done within the buckets, so primitives with the same z value will be drawn in the order they were inserted, but the buckets themselves will be drawn in order of decreasing z value, farthest bucket first, closest bucket last. When inserting a primitive inside an <code>OrderingTable&lt;N&gt;</code>, the z value should be in the range of 0 to N-1, with 0 being the closest to the camera, and N-1 being the farthest. If the z value is outside of this range, the primitive will be inserted into the closest bucket, with the z value clamped to the range.</p>
<p>The <code>OrderingTable</code> class can only be sent to the GPU using chaining. While not being a Fragment itself, it can be chained with other fragments. Multiple ordering tables can also be chained within the same scene, and they will be sent to the GPU in the order they were chained. This also means it is essential to double buffer the ordering tables, as they will be sent to the GPU in the background, and the code will continue executing.</p>
<p>Once the ordering table has been sent to the GPU, it will be cleared, and can be reused.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
Memory management</h1>
<p>Note that none of the current [examples](examples) are currently using any memory allocation, unless explicitly showcasing that memory allocation works. The core library itself may allocate memory, when it needs to overspill some heavy usage cases, but it should not be the general case.</p>
<p>Memory allocation in general with such a small amount of available memory is not necessarily a good idea, so it is generally recommended to avoid it. But all of the normal C++ memory allocation primitives should be working. Note that no standard libc is provided, so function calls like <code>malloc</code> and <code>free</code> are not directly available. The <code>psyqo_malloc</code> and <code>psyqo_free</code> functions are provided instead, and are the foundation of the <code>operator new</code> and <code>operator delete</code> functions.</p>
<h1><a class="anchor" id="autotoc_md48"></a>
Concurrency</h1>
<p>The major design principle of the PSYQo library is asynchronous callbacks. Most of the library is designed to be used in an asynchronous manner, and thus many of the functions are non-blocking. The only parts of the API which may be synchronous are inside the GPU subsystem, as it is the one designed to set the tempo of the application. Callbacks may be dispatched from any blocking GPU operation, and between frames. Some operations with asynchronous callbacks may complete successfully during the scheduling of the operation, and thus the callback may be dispatched immediately, from the same callstack as the scheduling method. Users of the library should be aware of this, and should not rely on callbacks always being dispatched at a later time.</p>
<p>In addition to asynchronous callbacks, there are facilities designed to help writing more readable asynchronous code.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Coroutines</h2>
<p>C++20 introduced support for coroutines. Coroutines are a way to write asynchronous code in a synchronous manner. They are a very powerful tool, and can be used to write very readable asynchronous code. <a href="https://pcsx-redux.github.io/nugget/d6/d6f/structpsyqo_1_1Coroutine.html">PSYQo has support for these coroutines</a>, and there is <a href="../../examples/coroutine-demo">an example</a> showcasing their usage. One important caveat is that the language will silently and implicitly use memory allocation to store the coroutine state, which may be a problem for some users. This is a limitation of the C++ language, and not of PSYQo.</p>
<p>In order to properly use coroutines, the function will need to have access to its coroutine object, so passing a pointer as a parameter that can give access to the coroutine object is necessary. The coroutine object can then be used to suspend the coroutine, and to resume it at a later time, usually during scheduled callbacks. For example:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_struct" href="../../d6/d6f/structpsyqo_1_1Coroutine.html">psyqo::Coroutine&lt;int&gt;</a> myCoroutine(SomeObject *container) {</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d6f/structpsyqo_1_1Coroutine.html">psyqo::Coroutine&lt;&gt;</a> *coroutine = &amp;container-&gt;coroutine;</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code hl_variable" href="../../d4/d16/memcpy_8c.html#aa2d4d3baa28317485d4a7c2911034b2a">result</a> = 0;</div>
<div class="line">    someAsyncOperation([coroutine, &amp;<a class="code hl_variable" href="../../d4/d16/memcpy_8c.html#aa2d4d3baa28317485d4a7c2911034b2a">result</a>](<span class="keywordtype">int</span> <a class="code hl_variable" href="../../d2/d6e/syscalls_8h.html#a1c6a9d4653e050269971b2e65f043746">value</a>) {</div>
<div class="line">        <a class="code hl_variable" href="../../d4/d16/memcpy_8c.html#aa2d4d3baa28317485d4a7c2911034b2a">result</a> = <a class="code hl_variable" href="../../d2/d6e/syscalls_8h.html#a1c6a9d4653e050269971b2e65f043746">value</a>;</div>
<div class="line">        coroutine-&gt;<a class="code hl_function" href="../../d6/d6f/structpsyqo_1_1Coroutine.html#acc462ae3a6a9cc4f4dd2688368482c9d">resume</a>();</div>
<div class="line">    });</div>
<div class="line">    <span class="keyword">co_await</span> coroutine-&gt;<a class="code hl_function" href="../../d6/d6f/structpsyqo_1_1Coroutine.html#a38233cb6fc84eeb249d40485f53d2763">awaiter</a>();</div>
<div class="line">    <span class="keyword">co_return</span> <a class="code hl_variable" href="../../d4/d16/memcpy_8c.html#aa2d4d3baa28317485d4a7c2911034b2a">result</a>;</div>
<div class="line">}</div>
<div class="ttc" id="amemcpy_8c_html_aa2d4d3baa28317485d4a7c2911034b2a"><div class="ttname"><a href="../../d4/d16/memcpy_8c.html#aa2d4d3baa28317485d4a7c2911034b2a">result</a></div><div class="ttdeci">void * result</div><div class="ttdef"><b>Definition</b> memcpy.c:47</div></div>
<div class="ttc" id="astructpsyqo_1_1Coroutine_html"><div class="ttname"><a href="../../d6/d6f/structpsyqo_1_1Coroutine.html">psyqo::Coroutine</a></div><div class="ttdoc">A suitable type to hold and return a C++20 coroutine.</div><div class="ttdef"><b>Definition</b> coroutine.hh:54</div></div>
<div class="ttc" id="astructpsyqo_1_1Coroutine_html_a38233cb6fc84eeb249d40485f53d2763"><div class="ttname"><a href="../../d6/d6f/structpsyqo_1_1Coroutine.html#a38233cb6fc84eeb249d40485f53d2763">psyqo::Coroutine::awaiter</a></div><div class="ttdeci">Awaiter awaiter()</div><div class="ttdoc">Creates an Awaiter object.</div><div class="ttdef"><b>Definition</b> coroutine.hh:131</div></div>
<div class="ttc" id="astructpsyqo_1_1Coroutine_html_acc462ae3a6a9cc4f4dd2688368482c9d"><div class="ttname"><a href="../../d6/d6f/structpsyqo_1_1Coroutine.html#acc462ae3a6a9cc4f4dd2688368482c9d">psyqo::Coroutine::resume</a></div><div class="ttdeci">void resume()</div><div class="ttdoc">Resumes the coroutine.</div><div class="ttdef"><b>Definition</b> coroutine.hh:142</div></div>
<div class="ttc" id="asyscalls_8h_html_a1c6a9d4653e050269971b2e65f043746"><div class="ttname"><a href="../../d2/d6e/syscalls_8h.html#a1c6a9d4653e050269971b2e65f043746">value</a></div><div class="ttdeci">static int value</div><div class="ttdef"><b>Definition</b> syscalls.h:534</div></div>
</div><!-- fragment --><p>The above coroutine will perform an asynchronous operation, and then return the result of that operation. The coroutine will be suspended until the asynchronous operation completes, and then resumed by its callback. The result will be held inside of the coroutine object for the caller to inspect. The <code>co_await</code> and <code>co_return</code> keywords are specific to coroutines, and are part of the C++ language as defined by the C++20 revision. The <code>co_await</code> keyword will suspend the coroutine, and the <code>co_return</code> keyword will terminate the coroutine and store the result inside of the coroutine object.</p>
<p>The caller must do something along these lines:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>SomeObject {</div>
<div class="line">    <a class="code hl_struct" href="../../d6/d6f/structpsyqo_1_1Coroutine.html">psyqo::Coroutine&lt;int&gt;</a> coroutine;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">SomeObject container;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::createScene() {</div>
<div class="line">    container.coroutine = myCoroutine(&amp;container);</div>
<div class="line">    container.coroutine.resume();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::frame() {</div>
<div class="line">    <span class="keywordflow">if</span> (container.coroutine.done()) {</div>
<div class="line">        <span class="keywordtype">int</span> <a class="code hl_variable" href="../../d4/d16/memcpy_8c.html#aa2d4d3baa28317485d4a7c2911034b2a">result</a> = container.coroutine.value();</div>
<div class="line">        <span class="comment">// Do something with the result.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The coroutine object will be in a "done" state after the coroutine has terminated, and can be reused by assigning a new coroutine to it. The <code>value</code> method will return the result of the coroutine, and can only be called after the coroutine has terminated. The <code>resume</code> method will start the coroutine, or resume it if it has been suspended. The <code>done</code> method will return <code>true</code> if the coroutine has terminated, and <code>false</code> otherwise. The coroutine starts in a suspended state, and must be resumed to begin operations. Resuming a coroutine that has already terminated will have no effect. Resuming a coroutine that is already running will likely end up in corruption of the coroutine state, and will likely result in a crash.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Task queue</h2>
<p>If the above coroutine system is too expensive, there is a less capable but more efficient way to still have a readable asynchronous code. The <a href="https://pcsx-redux.github.io/nugget/d4/db5/classpsyqo_1_1TaskQueue.html">TaskQueue</a> class allows for scheduling in advance a series of synchronous or asynchronous tasks that will be executed sequentially, loosely inspired by the JavaScript Promise system. There is a <a href="../../examples/task-demo">an example</a> showcasing its usage.</p>
<p>This system does not allow for loops or conditions, but will consume less resources overall than coroutines. It can be beneficial to use this system if the code is not expected to be very complex.</p>
<h1><a class="anchor" id="autotoc_md51"></a>
Further reading</h1>
<p>The <a href="../../examples/tetris">Tetris</a> example has a thorough usage of the library so far, and is a great example of how to use it. The library itself is also thoroughly documented, and the <a href="https://pcsx-redux.github.io/nugget/d6/d4a/namespacepsyqo.html">nugget website</a> has a render of the doxygen documentation.</p>
<p>Since the library is still very new and in flux, please refer to this page often as it is being updated with new concepts.</p>
<p>To discuss PlayStation1's development, hacking, and reverse engineering in general, please join the PSX.Dev Discord server: <a href="https://discord.gg/QByKPpH"><img src="https://img.shields.io/discord/642647820683444236" alt="Discord" class="inline"/></a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
