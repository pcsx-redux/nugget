<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nugget: psyqo::Kernel Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nugget
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d4a/namespacepsyqo.html">psyqo</a></li><li class="navelem"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html">Kernel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">psyqo::Kernel Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html" title="The Kernel namespace for internal use.">Kernel</a> namespace for internal use.  
<a href="../../db/d65/namespacepsyqo_1_1Kernel.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:da/dec/namespacepsyqo_1_1Kernel_1_1Internal" id="r_da/dec/namespacepsyqo_1_1Kernel_1_1Internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dec/namespacepsyqo_1_1Kernel_1_1Internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3fc8b0e7ce6de455589c212b024cdb98" id="r_a3fc8b0e7ce6de455589c212b024cdb98"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a> : unsigned { <br />
&#160;&#160;<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98a7d401456f9594b8f3b41aaa05b8473dc">MDECin</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98a581f36dfb2eac8e05acde5f9d65aca48">MDECout</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98a52f9ec21735243ad9917cda3ca077d32">GPU</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98aa9d0190c0b85654779d96e011d0b6d07">CDRom</a>
, <br />
&#160;&#160;<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98ada8a0d4a6c802e4d0bb48065258582b1">SPU</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98ad77d49c13fa357d3e951da9cfd01270d">EXP1</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98a99d34e1cefc7f86f9f4470d74e29e052">OTC</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98a6a061313d22e51e0f25b7cd4dc065233">Max</a>
<br />
 }</td></tr>
<tr class="separator:a3fc8b0e7ce6de455589c212b024cdb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b35e9b2bf1bbd73555bcd9ce8bb0189" id="r_a7b35e9b2bf1bbd73555bcd9ce8bb0189"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189">IRQ</a> : unsigned { <br />
&#160;&#160;<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189ad23364186c9aa9bca9ea12f6a7d2ecd5">VBlank</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189a52f9ec21735243ad9917cda3ca077d32">GPU</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189aa9d0190c0b85654779d96e011d0b6d07">CDRom</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189a33fd5f6391f2f0cb4c91179d7f521949">DMA</a>
, <br />
&#160;&#160;<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189aee8d7ab96a578300058b217be0b6e4b5">Timer0</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189a520b0824cea8417f3fde566f0019a2a7">Timer1</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189aa3df64ca11c5bfc17207d0db3b782e96">Timer2</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189a9bbf373797bf7cf7ba62c80023682e25">Controller</a>
, <br />
&#160;&#160;<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189ab2a303bb948b58961895b9797ee116c8">SIO</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189ada8a0d4a6c802e4d0bb48065258582b1">SPU</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189a7a876fbec890f829703bc77a76e8ef45">PIO</a>
, <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189a6a061313d22e51e0f25b7cd4dc065233">Max</a>
<br />
 }</td></tr>
<tr class="separator:a7b35e9b2bf1bbd73555bcd9ce8bb0189"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaf45f27dff984791bbdca08f459b691a" id="r_aaf45f27dff984791bbdca08f459b691a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#aaf45f27dff984791bbdca08f459b691a">takeOverKernel</a> ()</td></tr>
<tr class="memdesc:aaf45f27dff984791bbdca08f459b691a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes over the kernel. Can only be called once inside the main function.  <br /></td></tr>
<tr class="separator:aaf45f27dff984791bbdca08f459b691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f275c991805498a256274623da6459" id="r_aa9f275c991805498a256274623da6459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#aa9f275c991805498a256274623da6459">isKernelTakenOver</a> ()</td></tr>
<tr class="memdesc:aa9f275c991805498a256274623da6459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the kernel has been taken over.  <br /></td></tr>
<tr class="separator:aa9f275c991805498a256274623da6459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e39fef9fda59183ab7f2a58ae5df8" id="r_a5a5e39fef9fda59183ab7f2a58ae5df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a5a5e39fef9fda59183ab7f2a58ae5df8">installCrashHandler</a> ()</td></tr>
<tr class="memdesc:a5a5e39fef9fda59183ab7f2a58ae5df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a crash handler for the application.  <br /></td></tr>
<tr class="separator:a5a5e39fef9fda59183ab7f2a58ae5df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb7cdf1f775ac70cc620f6855c3a8c3" id="r_aaeb7cdf1f775ac70cc620f6855c3a8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#aaeb7cdf1f775ac70cc620f6855c3a8c3">queueIRQHandler</a> (<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189">IRQ</a> irq, eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;lambda)</td></tr>
<tr class="memdesc:aaeb7cdf1f775ac70cc620f6855c3a8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues an IRQ handler to be called from the exception handler.  <br /></td></tr>
<tr class="separator:aaeb7cdf1f775ac70cc620f6855c3a8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a2e5ec19c2fc81f09b2c298bdead6e" id="r_a08a2e5ec19c2fc81f09b2c298bdead6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a08a2e5ec19c2fc81f09b2c298bdead6e">openEvent</a> (<a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a> classId, <a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a> <a class="el" href="../../d2/d6e/syscalls_8h.html#a47df0658857c8a762f1811b9f868f34f">spec</a>, <a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a> <a class="el" href="../../d2/d6e/syscalls_8h.html#a8256fc5e2bb23abe5773b0310011eb03">mode</a>, eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;lambda)</td></tr>
<tr class="memdesc:a08a2e5ec19c2fc81f09b2c298bdead6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ wrapper around the <code>openEvent</code> syscall.  <br /></td></tr>
<tr class="separator:a08a2e5ec19c2fc81f09b2c298bdead6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b637b2a1916306cd06c949dd5052c1c" id="r_a2b637b2a1916306cd06c949dd5052c1c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a2b637b2a1916306cd06c949dd5052c1c">registerDmaEvent</a> (<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a> channel, eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;lambda)</td></tr>
<tr class="memdesc:a2b637b2a1916306cd06c949dd5052c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an ISR callback for a given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel.  <br /></td></tr>
<tr class="separator:a2b637b2a1916306cd06c949dd5052c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e42e7c13d0e282fa5521032b2f61885" id="r_a5e42e7c13d0e282fa5521032b2f61885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a5e42e7c13d0e282fa5521032b2f61885">flushCache</a> ()</td></tr>
<tr class="memdesc:a5e42e7c13d0e282fa5521032b2f61885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the i-cache.  <br /></td></tr>
<tr class="separator:a5e42e7c13d0e282fa5521032b2f61885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8e91701eacd417e8e12a3c8ea98046" id="r_aac8e91701eacd417e8e12a3c8ea98046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#aac8e91701eacd417e8e12a3c8ea98046">enableDma</a> (<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a> channel, unsigned priority=7)</td></tr>
<tr class="memdesc:aac8e91701eacd417e8e12a3c8ea98046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel.  <br /></td></tr>
<tr class="separator:aac8e91701eacd417e8e12a3c8ea98046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73aa87334a1770afc9b33af3d42ddd" id="r_a4b73aa87334a1770afc9b33af3d42ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a4b73aa87334a1770afc9b33af3d42ddd">disableDma</a> (<a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a> channel)</td></tr>
<tr class="memdesc:a4b73aa87334a1770afc9b33af3d42ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel.  <br /></td></tr>
<tr class="separator:a4b73aa87334a1770afc9b33af3d42ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72643d64b318dae4e7875d0e3a74007" id="r_aa72643d64b318dae4e7875d0e3a74007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#aa72643d64b318dae4e7875d0e3a74007">unregisterDmaEvent</a> (unsigned slot)</td></tr>
<tr class="memdesc:aa72643d64b318dae4e7875d0e3a74007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> callback slot.  <br /></td></tr>
<tr class="separator:aa72643d64b318dae4e7875d0e3a74007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884c0743af3b1284f6708359deb192d5" id="r_a884c0743af3b1284f6708359deb192d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a884c0743af3b1284f6708359deb192d5">queueCallback</a> (eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;lambda)</td></tr>
<tr class="memdesc:a884c0743af3b1284f6708359deb192d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a callback to be called from the main thead.  <br /></td></tr>
<tr class="separator:a884c0743af3b1284f6708359deb192d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154b2576841e7edcdb7d414c66059fe8" id="r_a154b2576841e7edcdb7d414c66059fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a154b2576841e7edcdb7d414c66059fe8">queueCallbackFromISR</a> (eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;lambda)</td></tr>
<tr class="memdesc:a154b2576841e7edcdb7d414c66059fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a callback to be called from the main thead.  <br /></td></tr>
<tr class="separator:a154b2576841e7edcdb7d414c66059fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4fedc050cfb0ca1dd509eb4451186" id="r_a5af4fedc050cfb0ca1dd509eb4451186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a5af4fedc050cfb0ca1dd509eb4451186">setBreakHandler</a> (unsigned category, eastl::function&lt; bool(<a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>)&gt; &amp;&amp;<a class="el" href="../../d2/d6e/syscalls_8h.html#a6dc4d0fa003a7621b96fcbd614845e06">handler</a>)</td></tr>
<tr class="memdesc:a5af4fedc050cfb0ca1dd509eb4451186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a break handler for a given category.  <br /></td></tr>
<tr class="separator:a5af4fedc050cfb0ca1dd509eb4451186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455444ce0a60f9799624ace6219a0d36" id="r_a455444ce0a60f9799624ace6219a0d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a455444ce0a60f9799624ace6219a0d36">queuePsyqoBreakHandler</a> (eastl::function&lt; bool(<a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>)&gt; &amp;&amp;<a class="el" href="../../d2/d6e/syscalls_8h.html#a6dc4d0fa003a7621b96fcbd614845e06">handler</a>)</td></tr>
<tr class="memdesc:a455444ce0a60f9799624ace6219a0d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a break handler for psyqo's reserved category.  <br /></td></tr>
<tr class="separator:a455444ce0a60f9799624ace6219a0d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280bdda777ef203032ff0767b5063ff1" id="r_a280bdda777ef203032ff0767b5063ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a280bdda777ef203032ff0767b5063ff1">assert</a> (bool condition, const char *message, std::source_location location=std::source_location::current())</td></tr>
<tr class="memdesc:a280bdda777ef203032ff0767b5063ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple <code>assert</code> macro.  <br /></td></tr>
<tr class="separator:a280bdda777ef203032ff0767b5063ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html" title="The Kernel namespace for internal use.">Kernel</a> namespace for internal use. </p>
<p>The <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html" title="The Kernel namespace for internal use.">Kernel</a> namespace is technically for internal use only, but it is included in the public API for convenience. It contains various glue to the actual PS1 kernel, as well as some useful utility functions. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3fc8b0e7ce6de455589c212b024cdb98" name="a3fc8b0e7ce6de455589c212b024cdb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc8b0e7ce6de455589c212b024cdb98">&#9670;&#160;</a></span>DMA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">psyqo::Kernel::DMA</a> : unsigned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98a7d401456f9594b8f3b41aaa05b8473dc" name="a3fc8b0e7ce6de455589c212b024cdb98a7d401456f9594b8f3b41aaa05b8473dc"></a>MDECin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98a581f36dfb2eac8e05acde5f9d65aca48" name="a3fc8b0e7ce6de455589c212b024cdb98a581f36dfb2eac8e05acde5f9d65aca48"></a>MDECout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98a52f9ec21735243ad9917cda3ca077d32" name="a3fc8b0e7ce6de455589c212b024cdb98a52f9ec21735243ad9917cda3ca077d32"></a>GPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98aa9d0190c0b85654779d96e011d0b6d07" name="a3fc8b0e7ce6de455589c212b024cdb98aa9d0190c0b85654779d96e011d0b6d07"></a>CDRom&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98ada8a0d4a6c802e4d0bb48065258582b1" name="a3fc8b0e7ce6de455589c212b024cdb98ada8a0d4a6c802e4d0bb48065258582b1"></a>SPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98ad77d49c13fa357d3e951da9cfd01270d" name="a3fc8b0e7ce6de455589c212b024cdb98ad77d49c13fa357d3e951da9cfd01270d"></a>EXP1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98a99d34e1cefc7f86f9f4470d74e29e052" name="a3fc8b0e7ce6de455589c212b024cdb98a99d34e1cefc7f86f9f4470d74e29e052"></a>OTC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3fc8b0e7ce6de455589c212b024cdb98a6a061313d22e51e0f25b7cd4dc065233" name="a3fc8b0e7ce6de455589c212b024cdb98a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b35e9b2bf1bbd73555bcd9ce8bb0189">&#9670;&#160;</a></span>IRQ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189">psyqo::Kernel::IRQ</a> : unsigned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189ad23364186c9aa9bca9ea12f6a7d2ecd5" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189ad23364186c9aa9bca9ea12f6a7d2ecd5"></a>VBlank&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189a52f9ec21735243ad9917cda3ca077d32" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189a52f9ec21735243ad9917cda3ca077d32"></a>GPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189aa9d0190c0b85654779d96e011d0b6d07" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189aa9d0190c0b85654779d96e011d0b6d07"></a>CDRom&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189a33fd5f6391f2f0cb4c91179d7f521949" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189a33fd5f6391f2f0cb4c91179d7f521949"></a>DMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189aee8d7ab96a578300058b217be0b6e4b5" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189aee8d7ab96a578300058b217be0b6e4b5"></a>Timer0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189a520b0824cea8417f3fde566f0019a2a7" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189a520b0824cea8417f3fde566f0019a2a7"></a>Timer1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189aa3df64ca11c5bfc17207d0db3b782e96" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189aa3df64ca11c5bfc17207d0db3b782e96"></a>Timer2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189a9bbf373797bf7cf7ba62c80023682e25" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189a9bbf373797bf7cf7ba62c80023682e25"></a>Controller&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189ab2a303bb948b58961895b9797ee116c8" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189ab2a303bb948b58961895b9797ee116c8"></a>SIO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189ada8a0d4a6c802e4d0bb48065258582b1" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189ada8a0d4a6c802e4d0bb48065258582b1"></a>SPU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189a7a876fbec890f829703bc77a76e8ef45" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189a7a876fbec890f829703bc77a76e8ef45"></a>PIO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b35e9b2bf1bbd73555bcd9ce8bb0189a6a061313d22e51e0f25b7cd4dc065233" name="a7b35e9b2bf1bbd73555bcd9ce8bb0189a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a280bdda777ef203032ff0767b5063ff1" name="a280bdda777ef203032ff0767b5063ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280bdda777ef203032ff0767b5063ff1">&#9670;&#160;</a></span>assert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::source_location&#160;</td>
          <td class="paramname"><em>location</em> = <code>std::source_location::current()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A simple <code>assert</code> macro. </p>

</div>
</div>
<a id="a4b73aa87334a1770afc9b33af3d42ddd" name="a4b73aa87334a1770afc9b33af3d42ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b73aa87334a1770afc9b33af3d42ddd">&#9670;&#160;</a></span>disableDma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::disableDma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a>&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac8e91701eacd417e8e12a3c8ea98046" name="aac8e91701eacd417e8e12a3c8ea98046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8e91701eacd417e8e12a3c8ea98046">&#9670;&#160;</a></span>enableDma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::enableDma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>priority</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel to enable. </td></tr>
    <tr><td class="paramname">priority</td><td>the priority of the channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e42e7c13d0e282fa5521032b2f61885" name="a5e42e7c13d0e282fa5521032b2f61885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e42e7c13d0e282fa5521032b2f61885">&#9670;&#160;</a></span>flushCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::flushCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the i-cache. </p>
<p>This function is used to flush the i-cache. This is required when the application has written some code to memory. </p>

</div>
</div>
<a id="a5a5e39fef9fda59183ab7f2a58ae5df8" name="a5a5e39fef9fda59183ab7f2a58ae5df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5e39fef9fda59183ab7f2a58ae5df8">&#9670;&#160;</a></span>installCrashHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::installCrashHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a crash handler for the application. </p>
<p>This function installs a crash handler for the application. The crash handler will be called when the application crashes, such when an unhandled exception occurs. It will display a message on the screen with the crash information, including the exception type, the exception address, and the value of all the registers at the time of the crash. The crash handler requires the system font to be uploaded to VRAM, at the default location (960, 464). If the system font is not available, the crash handler will not be able to display the message properly.</p>
<p>As usual, this function should be called from <code>main</code>, before handing over control to the application, it should only be called once, and its associated cost will only be added to the binary if it is called. </p>

</div>
</div>
<a id="aa9f275c991805498a256274623da6459" name="aa9f275c991805498a256274623da6459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f275c991805498a256274623da6459">&#9670;&#160;</a></span>isKernelTakenOver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool psyqo::Kernel::isKernelTakenOver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the kernel has been taken over. </p>

</div>
</div>
<a id="a08a2e5ec19c2fc81f09b2c298bdead6e" name="a08a2e5ec19c2fc81f09b2c298bdead6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a2e5ec19c2fc81f09b2c298bdead6e">&#9670;&#160;</a></span>openEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a> psyqo::Kernel::openEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>classId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A C++ wrapper around the <code>openEvent</code> syscall. </p>
<p>This enables the application to register a C++ lambda for the kernel's OpenEvent call. This will allocate an internal slot, with currently no mechanism to free it. This means that calling <code>closeEvent</code> on the resulting event will leak resources. If psyqo took over the kernel, this function will no longer work. </p>

</div>
</div>
<a id="a884c0743af3b1284f6708359deb192d5" name="a884c0743af3b1284f6708359deb192d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884c0743af3b1284f6708359deb192d5">&#9670;&#160;</a></span>queueCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::queueCallback </td>
          <td>(</td>
          <td class="paramtype">eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a callback to be called from the main thead. </p>
<p>This function is used to queue a callback to be called from the main thread, during idle moments like various blocking operations. This variant is safe to call from the main thread only. Its usefulness from the main thread is limited, and could be considered the same as JavaScript's <code>process.nextTick()</code>, meaning it's a great way to avoid get out of a deep callstack. </p>

</div>
</div>
<a id="a154b2576841e7edcdb7d414c66059fe8" name="a154b2576841e7edcdb7d414c66059fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154b2576841e7edcdb7d414c66059fe8">&#9670;&#160;</a></span>queueCallbackFromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::queueCallbackFromISR </td>
          <td>(</td>
          <td class="paramtype">eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a callback to be called from the main thead. </p>
<p>This function is used to queue a callback to be called from the main thead, during idle moments like various blocking operations. This variant is safe to call from an interrupt handler. This is how to idiomatically execute something safely from an interrupt handler. </p>

</div>
</div>
<a id="aaeb7cdf1f775ac70cc620f6855c3a8c3" name="aaeb7cdf1f775ac70cc620f6855c3a8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb7cdf1f775ac70cc620f6855c3a8c3">&#9670;&#160;</a></span>queueIRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::queueIRQHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a7b35e9b2bf1bbd73555bcd9ce8bb0189">IRQ</a>&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues an IRQ handler to be called from the exception handler. </p>
<p>This function is used to queue an IRQ handler to be called from the exception handler when the kernel has been taken over. While it is technically possible to queue VBlank, it should solely be reserved for the <a class="el" href="../../db/dcc/classpsyqo_1_1GPU.html" title="The singleton GPU class.">GPU</a> object instead. Also, note that the kernel has its own <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> IRQ handler, and that the <code>registerDmaEvent</code> function should be used instead of trying to queue a handler for the <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> IRQ. The specified handler will be called from the exception handler, with the same restrictions as for any other interrupt handler. The queued handlers will be called in the order they were queued, but it is recommended to only queue one handler per IRQ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>The IRQ to handle. </td></tr>
    <tr><td class="paramname">lambda</td><td>The function to call when the IRQ is triggered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a455444ce0a60f9799624ace6219a0d36" name="a455444ce0a60f9799624ace6219a0d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455444ce0a60f9799624ace6219a0d36">&#9670;&#160;</a></span>queuePsyqoBreakHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::queuePsyqoBreakHandler </td>
          <td>(</td>
          <td class="paramtype">eastl::function&lt; bool(<a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a break handler for psyqo's reserved category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to call when a break occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b637b2a1916306cd06c949dd5052c1c" name="a2b637b2a1916306cd06c949dd5052c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b637b2a1916306cd06c949dd5052c1c">&#9670;&#160;</a></span>registerDmaEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned psyqo::Kernel::registerDmaEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d65/namespacepsyqo_1_1Kernel.html#a3fc8b0e7ce6de455589c212b024cdb98">DMA</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eastl::function&lt; <a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a>()&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an ISR callback for a given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel. </p>
<p>The PSYQo kernel registers a dispatcher interrupt handler for <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> interrupts, and this function registers a callback function for a given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> channel. Multiple callbacks can be registered for a given channel. All the callbacks registered will be called sequentially during the dispatcher interrupt handler. Note this means the callbacks will be called from the interrupt handler, with the same restrictions as for any other interrupt handler. </p><dl class="section return"><dt>Returns</dt><dd>unsigned A slot id for the given callback. </dd></dl>

</div>
</div>
<a id="a5af4fedc050cfb0ca1dd509eb4451186" name="a5af4fedc050cfb0ca1dd509eb4451186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af4fedc050cfb0ca1dd509eb4451186">&#9670;&#160;</a></span>setBreakHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::setBreakHandler </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eastl::function&lt; bool(<a class="el" href="../../d2/d6e/syscalls_8h.html#afc8cf906e2f0373da36f37c55ce569a1">uint32_t</a>)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a break handler for a given category. </p>
<p>This function is used to set a break handler for a given category. The category is technically the upper 10 bits of the break code, and the handler is a function that takes the lower 10 bits of the break code. The handler should return true if it handled the break, and false otherwise. The handler will be called from the exception handler, with the same restrictions as for any other interrupt handler. Note that the category is actually limited to 16 categories by psyqo, from 0 to 15. It is also worth noting that category 0 is usually reserved for pcdrv, category 7 is reserved by the compiler to emit division by zero checks, and psyqo uses category 14 for its own purposes. Only one handler can be set per category, and trying to set a handler for a category that already has a handler will cause an assertion failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>The category to handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf45f27dff984791bbdca08f459b691a" name="aaf45f27dff984791bbdca08f459b691a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf45f27dff984791bbdca08f459b691a">&#9670;&#160;</a></span>takeOverKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::takeOverKernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes over the kernel. Can only be called once inside the main function. </p>
<p>This function will make psyqo take over the retail kernel. This means the application will no longer be able to call any of the kernel functions, and will have to rely on the psyqo kernel instead. Debugging features from third party addons which hook into the kernel will no longer work. Most calls to the kernel will either be no-ops or will crash the application. Most notably, only the <code>printf</code> call will be redirected to psyqo's printf, but will not be printing anywhere, so only emulators hooking into A0 calls will be able to see the output.</p>
<p>Disabling the kernel is a one-way operation, and cannot be undone. The kernel will be taken over before the first call to <code>prepare</code>. The exception handler that psyqo installs will not be able to catch problems, but is much more lightweight and faster than the retail one. Also, 60kB of memory can be reclaimed, and linking the binary with -Xlinker &ndash;defsym=TLOAD_ADDR=0x80001000 will allow the application to do just that. This requires a loader able to write into the kernel while disabling interrupts. The ps1-packer tool can achieve that. The first 4kB of memory is reserved for the psyqo kernel.</p>
<p>It is noteworthy that while the pros of taking over the kernel are significant, the cons are also significant. The loss of debugging, flexibility, and retail kernel features may not be worth it for most application cases, and should be considered carefully.</p>
<p>Last but not least, like with most psyqo features, the added payload to the binary to support the feature will only occur if this function is called. </p>

</div>
</div>
<a id="aa72643d64b318dae4e7875d0e3a74007" name="aa72643d64b318dae4e7875d0e3a74007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72643d64b318dae4e7875d0e3a74007">&#9670;&#160;</a></span>unregisterDmaEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d6e/syscalls_8h.html#ac7b52b23779bbd71ccd936383c447ba3">void</a> psyqo::Kernel::unregisterDmaEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given <a class="el" href="../../dc/d50/namespacepsyqo_1_1DMA.html">DMA</a> callback slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>The slot to free, as returned by <code>registerDmaEvent</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
